<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>SteelSketch</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  :root{
    --left-w:280px;
    --right-w:320px;
    --toolbar-h:60px;
    --bg:#f8fafc;
    --accent:#1e40af;
    --accent-hover:#1d4ed8;
    --border:#e2e8f0;
    --shadow-sm:0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --text-primary:#0f172a;
    --text-secondary:#64748b;
  }
  * { box-sizing: border-box; }
  html,body{height:100%;margin:0;font-family:'Inter',sans-serif;background:var(--bg);}
  /* toolbar top */
  #topbar{
    position:fixed;left:0;right:var(--right-w);top:0;height:var(--toolbar-h);
    background:white;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px;padding:8px 16px;z-index:40;box-shadow:var(--shadow-sm);
  }
  #logo{height:36px;width:auto}
  #topbar .group{display:flex;gap:8px;align-items:center}
  #topbar button, #topbar select, #topbar input{padding:8px 12px;border-radius:8px;border:1px solid var(--border);background:white;cursor:pointer;font-size:14px;transition:all 0.2s;}
  #topbar button:hover{transform:translateY(-1px);box-shadow:var(--shadow-sm);}
  #topbar button.primary{background:var(--accent);color:white;border:none}
  #topbar button.primary:hover{background:var(--accent-hover);}
  /* left panel */
  #leftPanel{
    position:fixed;left:0;top:var(--toolbar-h);bottom:0;width:var(--left-w);
    background:white;border-right:1px solid var(--border);padding:16px;overflow:auto;box-shadow:var(--shadow-sm);
  }
  #leftPanel h3{margin:0 0 12px 0;font-size:16px;font-weight:600;color:var(--text-primary)}
  .panel{background:white;border:1px solid var(--border);padding:16px;border-radius:12px;margin-bottom:16px;box-shadow:var(--shadow-sm)}
  label{display:block;font-size:13px;margin-bottom:6px;color:var(--text-secondary);font-weight:500}
  input[type=number], select, input[type=text]{width:100%;padding:8px;border:1px solid var(--border);border-radius:8px;font-size:14px;transition:border-color 0.2s;}
  input[type=number]:focus, select:focus{border-color:var(--accent);outline:none;}
  .toolbtn{display:block;width:100%;text-align:left;padding:12px;border-radius:8px;border:1px solid var(--border);margin-bottom:8px;background:white;cursor:pointer;font-size:14px;transition:all 0.2s;}
  .toolbtn:hover{background:#f1f5f9;}
  .toolbtn.active{background:linear-gradient(135deg,var(--accent)/0.1,transparent);border-color:var(--accent);font-weight:500}
  /* center canvas area */
  #canvasWrap{position:fixed;left:var(--left-w);right:var(--right-w);top:var(--toolbar-h);bottom:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#f1f5f9,#e2e8f0);overflow:auto;}
  #workArea{position:relative;background:transparent;border-radius:12px;box-shadow:var(--shadow-md);padding:24px}
  canvas{background:white;border:2px solid var(--border);border-radius:12px;display:block;cursor:crosshair;transition:box-shadow 0.2s;}
  canvas:hover{box-shadow:var(--shadow-md);}
  /* right panel */
  #rightPanel{
    position:fixed;right:0;top:0;bottom:0;width:var(--right-w);background:white;border-left:1px solid var(--border);padding:16px;overflow:auto;box-shadow:var(--shadow-sm);
  }
  h4{margin:0 0 12px 0;font-size:16px;font-weight:600;color:var(--text-primary)}
  .stat{background:white;padding:16px;border-radius:12px;border:1px solid var(--border);margin-bottom:12px;box-shadow:var(--shadow-sm)}
  .muted{color:var(--text-secondary);font-size:14px}
  .small{font-size:12px;color:var(--text-secondary)}
  .bignum{font-weight:600;font-size:20px;color:var(--text-primary)}
  /* explorer property panel - accordion style */
  .property-panel{background:white;padding:12px;border-radius:12px;border:1px solid var(--border);margin-bottom:12px;box-shadow:var(--shadow-sm);cursor:pointer;transition:all 0.2s;}
  .property-panel:hover{box-shadow:var(--shadow-md);transform:translateY(-1px);}
  .property-panel summary{font-weight:500;color:var(--text-primary);list-style:none;}
  .property-panel summary::-webkit-details-marker{display:none;}
  .property-panel[open] summary{font-weight:600;}
  .property-panel input{width:80px;margin-right:8px;padding:6px;border:1px solid var(--border);border-radius:6px;font-size:12px;}
  .property-panel input:focus{border-color:var(--accent);}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}
  footer.note{font-size:12px;color:var(--text-secondary);margin-top:16px;text-align:center}
  /* responsive */
  @media(max-width:1000px){ #leftPanel{display:none} #rightPanel{display:none} #topbar{right:0} #canvasWrap{left:0;right:0} }
  .tooltip { position: relative; display: inline-block; border-bottom: 1px dotted var(--text-secondary); }
  .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #334155; color: white; text-align: left; border-radius: 8px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 12px; }
  .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
  .btn-group{display:flex;gap:8px;margin-top:8px;}
  button.small{padding:4px 8px;font-size:12px;}
</style>
</head>
<body>
  <!-- TOP BAR -->
  <div id="topbar">
    <div class="group">
      <img id="logo" src="https://via.placeholder.com/40x40/1e40af/ffffff?text=SS" alt="SteelSketch" />
      <strong style="font-size:18px;">SteelSketch</strong>
    </div>

    <div class="group" style="margin-left:auto">
      <label style="font-size:12px;margin:0 6px 0 0;color:var(--text-secondary)">Zoom</label>
      <select id="zoomSelect"><option>50%</option><option selected>100%</option><option>150%</option><option>200%</option><option>250%</option></select>
      <select id="nestAlgo"><option>first-fit</option><option selected>best-fit</option></select>
      <button id="optimizeBtn" class="primary">Optimiser</button>
      <button id="simulateBtn">Simuler</button>
    </div>

    <div class="group">
      <label style="font-size:12px;margin:0 6px 0 0;color:var(--text-secondary)">Kerf (mm)</label>
      <input id="kerf" type="number" value="1" step="0.1" style="width:70px">
      <div class="btn-group">
        <button id="exportDXF" class="small">DXF</button>
        <button id="exportGCode" class="small">G-code</button>
        <button id="exportPDF" class="small">PDF</button>
      </div>
    </div>
  </div>

  <!-- LEFT PANEL -->
  <aside id="leftPanel">
    <h3>Configuration Tôle</h3>
    <div class="panel">
      <label>Largeur (mm)</label><input id="sheetW" type="number" value="800">
      <label>Hauteur (mm)</label><input id="sheetH" type="number" value="600">
      <label>Épaisseur (mm)</label><input id="thickness" type="number" value="3" step="0.1">
      <label>Matériau</label>
      <select id="material">
        <option value="steel">Acier</option>
        <option value="alu">Aluminium</option>
        <option value="inox">Inox</option>
        <option value="copper">Cuivre</option>
      </select>
      <div class="btn-group">
        <button id="applySheet" style="flex:1;background:var(--accent);color:white;border:none">Appliquer</button>
        <button id="clearBtn" style="flex:1">Effacer</button>
      </div>
    </div>

    <h3>Outils</h3>
    <div class="panel">
      <button class="toolbtn active" id="tool_select" title="Sélection / Déplacer / Suppr (Shift+clic)">Sélection</button>
      <button class="toolbtn" id="tool_rect" title="Rectangle pour découpe">Rectangle</button>
      <button class="toolbtn" id="tool_circle" title="Cercle">Cercle</button>
      <button class="toolbtn" id="tool_line" title="Ligne droite">Ligne</button>
      <button class="toolbtn" id="tool_triangle" title="Triangle rectangle">Triangle</button>
      <button class="toolbtn" id="tool_polygon" title="Polygone (clic droit pour fermer)">Polygone</button>
      <button class="toolbtn" id="tool_bend" title="Ligne de pliage">Pli</button>
    </div>

    <h3>Calques</h3>
    <div class="panel">
      <label><input type="checkbox" checked id="layer_cut"> Découpe</label>
      <label><input type="checkbox" checked id="layer_mark"> Marquage</label>
      <label><input type="checkbox" checked id="layer_bend"> Pliage</label>
      <label><input type="checkbox" checked id="layer_drill"> Perçage</label>
    </div>

    <h3>Options</h3>
    <div class="panel">
      <label><input type="checkbox" id="gridToggle" checked> Quadrillage adaptatif</label>
      <label><input type="checkbox" id="pedagoMode"> Mode pédagogique</label>
    </div>

    <div class="panel">
      <div class="muted" style="font-size:13px;">Aide</div>
      <div class="small" style="line-height:1.4;">Drag pour déplacer les formes sélectionnées. Optimisation auto avec best-fit. Exports prêts pour fabrication. Mode pédago : survol pour tooltips.</div>
    </div>
  </aside>

  <!-- CENTER WORK AREA -->
  <div id="canvasWrap">
    <div id="workArea">
      <canvas id="canvas" width="1000" height="700"></canvas>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <aside id="rightPanel">
    <h4>Analyse</h4>
    <div class="stat">
      <div class="muted">Surface tôle</div>
      <div class="bignum" id="stat_sheetArea">—</div>
      <div class="muted" id="stat_dims">—</div>
    </div>

    <div class="stat">
      <div class="muted">Surface utilisée</div>
      <div class="bignum" id="stat_cutArea">0 mm²</div>
      <div class="muted">Utilisation <span id="stat_util">0%</span> • Chutes <span id="stat_waste">100%</span></div>
    </div>

    <div class="stat">
      <div class="muted">Poids</div>
      <div class="bignum" id="stat_weight">0 kg</div>
      <div class="muted">Coût : <span id="stat_cost">0 €</span></div>
    </div>

    <h4>Explorer</h4>
    <div id="properties"></div>

    <footer class="note">
      SteelSketch • v2.0 • Éducatif & Pro
    </footer>
  </aside>
<script>
/* ======================
   Utilitaires & état
   ====================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const canvasWrap = document.getElementById('canvasWrap');

let tool = 'select';
let shapes = []; 
let drawing = false, dragging = false, panning = false, dragOffsetX = 0, dragOffsetY = 0, panOffsetX = 0, panOffsetY = 0, startX=0, startY=0, currentShape=null;
let selectedShape = null;
let sheet = {x:50,y:50,width:800,height:600,scale:1,thickness:3,material:'steel'}; // Initial offset for pan
const materialsDB = {
  steel:{name:'Acier', density:7850, price:1.5},
  alu:{name:'Aluminium', density:2700, price:3.0},
  inox:{name:'Inox', density:8000, price:2.5},
  copper:{name:'Cuivre', density:8960, price:6.0}
};
const defaultColors = {
  rect: 'rgba(59,130,246,0.2)',
  circle: 'rgba(239,68,68,0.2)',
  line: 'rgba(34,197,94,0.2)',
  triangle: 'rgba(251,191,36,0.2)',
  polygon: 'rgba(168,85,247,0.2)',
  bend: 'rgba(245,101,101,0.3)'
};
const kerfInput = document.getElementById('kerf');
const zoomSelect = document.getElementById('zoomSelect');
const nestAlgoSelect = document.getElementById('nestAlgo');
let zoomFactor = 1.0;
let baseScale = 1.0;
const pedagoMode = document.getElementById('pedagoMode');
const gridToggle = document.getElementById('gridToggle');

/* initialize UI elements */
function $id(i){return document.getElementById(i)}
$id('applySheet').addEventListener('click', applySheetConfig);
$id('clearBtn').addEventListener('click', ()=>{ shapes=[]; redraw(); });
$id('tool_rect').addEventListener('click', ()=>selectTool('rect'));
$id('tool_circle').addEventListener('click', ()=>selectTool('circle'));
$id('tool_line').addEventListener('click', ()=>selectTool('line'));
$id('tool_triangle').addEventListener('click', ()=>selectTool('triangle'));
$id('tool_select').addEventListener('click', ()=>selectTool('select'));
$id('tool_polygon').addEventListener('click', ()=>selectTool('polygon'));
$id('tool_bend').addEventListener('click', ()=>selectTool('bend'));
$id('optimizeBtn').addEventListener('click', ()=>optimizeLayout());
$id('simulateBtn').addEventListener('click', simulateTrajectory);
$id('exportDXF').addEventListener('click', exportDXF);
$id('exportGCode').addEventListener('click', exportGCode);
$id('exportPDF').addEventListener('click', exportPDF);
zoomSelect.addEventListener('change', applyZoom);
[$id('layer_cut'), $id('layer_mark'), $id('layer_bend'), $id('layer_drill')].forEach(cb => cb.addEventListener('change', redraw));
pedagoMode.addEventListener('change', () => { if(pedagoMode.checked) pedagoAlert('Mode pédagogique activé : Survolez pour des astuces.'); });
gridToggle.addEventListener('change', redraw);

function selectTool(t){
  tool = t;
  document.querySelectorAll('.toolbtn').forEach(b=>b.classList.remove('active'));
  $id(`tool_${t}`).classList.add('active');
  currentShape = null; dragging = false; panning = false;
  canvas.style.cursor = t === 'select' ? 'grab' : 'crosshair';
  if(pedagoMode.checked) pedagoAlert(`Outil ${t} : ${getToolTip(t)}`);
}

function pedagoAlert(msg) {
  if(pedagoMode.checked) {
    // Use modern toast-like, but for simplicity, alert
    alert(msg);
  }
}

function getToolTip(t) {
  const tips = {
    select: 'Drag pour pan/zoom, clic pour sélectionner/déplacer (Shift+clic suppr).',
    rect: 'Drag pour rectangle, fonctionne dans tous les sens.',
    circle: 'Drag depuis centre pour rayon.',
    line: 'Drag pour ligne droite.',
    triangle: 'Drag pour base/hauteur.',
    polygon: 'Clics pour points, droit pour fermer.',
    bend: 'Ligne pour pliage (calque séparé).'
  };
  return tips[t] || 'Outil de dessin.';
}

/* ======================
   Sheet config & centering
   ====================== */
function applySheetConfig(){
  const w = parseFloat($id('sheetW').value) || 800;
  const h = parseFloat($id('sheetH').value) || 600;
  sheet.width = w; sheet.height = h;
  sheet.thickness = parseFloat($id('thickness').value) || 3;
  sheet.material = $id('material').value;

  // Compute base scale
  const margin = 80;
  const scaleX = (canvas.width - margin*2) / w;
  const scaleY = (canvas.height - margin*2) / h;
  baseScale = Math.min(scaleX, scaleY);
  sheet.scale = baseScale * zoomFactor;

  // Center with pan
  sheet.x = (canvas.width - w * sheet.scale) / 2 + panOffsetX;
  sheet.y = (canvas.height - h * sheet.scale) / 2 + panOffsetY;

  redraw();
}

/* ======================
   Zoom & Pan
   ====================== */
function applyZoom() {
  zoomFactor = parseFloat(zoomSelect.value) / 100;
  sheet.scale = baseScale * zoomFactor;
  canvas.style.transform = `scale(${zoomFactor})`;
  canvas.style.transformOrigin = 'center center';
  applySheetConfig(); // Recenter
}

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  const currentZoom = parseFloat(zoomSelect.value);
  let newZoom = Math.max(50, Math.min(300, currentZoom * delta));
  zoomSelect.value = Math.round(newZoom) + '%';
  applyZoom();
});

/* ======================
   Mouse events - drawing, dragging, panning
   ====================== */
canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  let clientX = (e.clientX - rect.left) / zoomFactor;
  let clientY = (e.clientY - rect.top) / zoomFactor;
  startX = clientX;
  startY = clientY;

  if(!pointInSheet(clientX, clientY)){ 
    if(tool === 'select') panning = true;
    return; 
  }

  if(tool === 'select'){
    const idx = findShapeIndexAt(clientX, clientY);
    if(idx !== -1){
      selectedShape = idx;
      dragging = true;
      const s = shapes[idx];
      dragOffsetX = clientX - (s.x || s.points[0].x);
      dragOffsetY = clientY - (s.y || s.points[0].y);
      if(e.shiftKey){
        shapes.splice(idx,1); selectedShape = null; redraw(); return;
      }
    } else {
      selectedShape = null;
    }
    canvas.style.cursor = dragging ? 'grabbing' : 'grab';
    redraw();
    return;
  }

  drawing = true;
  const layer = tool === 'bend' ? 'bend' : 'cut';
  if(tool === 'rect' || tool === 'triangle'){
    currentShape = {type:tool, x:clientX, y:clientY, w:0, h:0, rotation:0, layer};
    shapes.push(currentShape);
  } else if(tool === 'circle'){
    currentShape = {type:'circle', x:clientX, y:clientY, r:0, layer};
    shapes.push(currentShape);
  } else if(tool === 'line' || tool === 'bend'){
    currentShape = {type:'line', x:clientX, y:clientY, x2:clientX, y2:clientY, layer};
    shapes.push(currentShape);
  } else if(tool === 'polygon'){
    if (!currentShape || currentShape.type !== 'polygon') {
      currentShape = {type:'polygon', points:[{x:clientX, y:clientY}], layer, closed:false};
      shapes.push(currentShape);
    } else {
      currentShape.points.push({x:clientX, y:clientY});
    }
  }
  redraw();
});

canvas.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  let clientX = (e.clientX - rect.left) / zoomFactor;
  let clientY = (e.clientY - rect.top) / zoomFactor;

  if(panning){
    panOffsetX += (clientX - startX);
    panOffsetY += (clientY - startY);
    startX = clientX; startY = clientY;
    applySheetConfig();
    return;
  }

  if(dragging && selectedShape !== null){
    const s = shapes[selectedShape];
    const newX = clientX - dragOffsetX;
    const newY = clientY - dragOffsetY;
    const dx = newX - (s.x || s.points[0].x);
    const dy = newY - (s.y || s.points[0].y);
    if(s.type === 'rect' || s.type === 'triangle' || s.type === 'circle'){
      s.x += dx; s.y += dy;
    } else if(s.type === 'line'){
      s.x += dx; s.y += dy; s.x2 += dx; s.y2 += dy;
    } else if(s.type === 'polygon'){
      s.points.forEach(p => { p.x += dx; p.y += dy; });
    }
    clampShapeToSheet(s);
    redraw();
  } else if(drawing && currentShape){
    let mx = clientX, my = clientY;
    if(currentShape.type === 'rect' || currentShape.type === 'triangle'){
      currentShape.w = mx - currentShape.x;
      currentShape.h = my - currentShape.y;
      normalizeShapeWH(currentShape);
    } else if(currentShape.type === 'circle'){
      currentShape.r = Math.hypot(mx - currentShape.x, my - currentShape.y);
    } else if(currentShape.type === 'line' || currentShape.type === 'bend'){
      currentShape.x2 = mx; currentShape.y2 = my;
    }
    clampShapeToSheet(currentShape);
    redraw();
  }
});

canvas.addEventListener('mouseup', (e)=>{
  drawing = false;
  dragging = false;
  panning = false;
  currentShape = null;
  canvas.style.cursor = tool === 'select' ? 'grab' : 'crosshair';
  redraw();
});

// Right-click to close polygon
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  if (tool === 'polygon' && shapes.length > 0 && !shapes[shapes.length - 1].closed) {
    shapes[shapes.length - 1].closed = true;
    currentShape = null;
    drawing = false;
    redraw();
  }
});

/* helper normalize negative width/height */
function normalizeShapeWH(s){
  if((s.type === 'rect' || s.type === 'triangle') && (s.w < 0 || s.h < 0)){
    if(s.w < 0){ s.x += s.w; s.w = -s.w; }
    if(s.h < 0){ s.y += s.h; s.h = -s.h; }
  }
}

/* ======================
   Drawing functions
   ====================== */
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();

  // draw sheet
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = '#1e293b';
  ctx.lineWidth = 2;
  ctx.fillRect(sheet.x, sheet.y, sheet.width*sheet.scale, sheet.height*sheet.scale);
  ctx.strokeRect(sheet.x, sheet.y, sheet.width*sheet.scale, sheet.height*sheet.scale);

  // Sheet grid adaptive
  if(gridToggle.checked) drawSheetGrid();

  // Center lines
  ctx.save();
  ctx.strokeStyle = 'rgba(34,197,94,0.6)';
  ctx.setLineDash([5,5]);
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sheet.x + (sheet.width*sheet.scale)/2, sheet.y);
  ctx.lineTo(sheet.x + (sheet.width*sheet.scale)/2, sheet.y + sheet.height*sheet.scale);
  ctx.moveTo(sheet.x, sheet.y + (sheet.height*sheet.scale)/2);
  ctx.lineTo(sheet.x + sheet.width*sheet.scale, sheet.y + (sheet.height*sheet.scale)/2);
  ctx.stroke();
  ctx.restore();

  // draw shapes
  shapes.forEach((s,idx)=>{
    if (!shouldDrawLayer(s.layer)) return;
    drawShape(s, idx === selectedShape);
  });

  updateStats();
  buildExplorer();
}

function drawSheetGrid(){
  const numDivs = 10; // 10x10 grid
  const stepX = (sheet.width * sheet.scale) / numDivs;
  const stepY = (sheet.height * sheet.scale) / numDivs;
  ctx.save();
  ctx.strokeStyle = '#e2e8f0';
  ctx.lineWidth = 1;
  // Vertical lines
  for(let i = 0; i <= numDivs; i++){
    const gx = sheet.x + i * stepX;
    ctx.beginPath(); ctx.moveTo(gx, sheet.y); ctx.lineTo(gx, sheet.y + sheet.height * sheet.scale); ctx.stroke();
  }
  // Horizontal lines
  for(let i = 0; i <= numDivs; i++){
    const gy = sheet.y + i * stepY;
    ctx.beginPath(); ctx.moveTo(sheet.x, gy); ctx.lineTo(sheet.x + sheet.width * sheet.scale, gy); ctx.stroke();
  }
  ctx.restore();
}

function drawGrid(){
  const step = 25;
  ctx.save();
  ctx.fillStyle = '#f1f5f9';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = '#e2e8f0';
  ctx.lineWidth = 0.5;
  for(let x = 0; x < canvas.width; x += step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
  }
  for(let y = 0; y < canvas.height; y += step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
  }
  ctx.restore();
}

function drawShape(s, highlight=false){
  ctx.save();
  ctx.lineWidth = highlight ? 3 : 2;
  ctx.strokeStyle = highlight ? '#f59e0b' : (s.layer === 'bend' ? '#ef4444' : '#475569');
  ctx.fillStyle = defaultColors[s.type] || 'rgba(148,163,184,0.2)';
  ctx.beginPath();

  if(s.type === 'rect'){
    ctx.fillRect(s.x, s.y, s.w, s.h);
    ctx.strokeRect(s.x, s.y, s.w, s.h);
    ctx.fillStyle = '#0f172a'; ctx.font = '11px Inter'; ctx.fillText(`${Math.round(s.w/sheet.scale)}×${Math.round(s.h/sheet.scale)}mm`, s.x + 4, s.y + 14);
  } else if(s.type === 'circle'){
    ctx.arc(s.x + s.r, s.y + s.r, s.r, 0, Math.PI*2); // Center at x+r, y+r? No, x,y is center
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#0f172a'; ctx.font='11px Inter';
    ctx.fillText(`Ø${Math.round(2*s.r/sheet.scale)}mm`, s.x - s.r, s.y + 4);
  } else if(s.type === 'line'){
    ctx.moveTo(s.x, s.y); ctx.lineTo(s.x2, s.y2); ctx.stroke();
    const len = Math.hypot(s.x2-s.x, s.y2-s.y)/sheet.scale;
    ctx.fillStyle = '#0f172a'; ctx.font='11px Inter';
    ctx.fillText(`${Math.round(len)}mm`, (s.x+s.x2)/2 + 4, (s.y+s.y2)/2 + 4);
  } else if(s.type === 'triangle'){
    ctx.moveTo(s.x, s.y + s.h); ctx.lineTo(s.x, s.y); ctx.lineTo(s.x + s.w, s.y + s.h); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#0f172a'; ctx.font='11px Inter';
    ctx.fillText(`${Math.round(s.w/sheet.scale)}×${Math.round(s.h/sheet.scale)}mm`, s.x + 4, s.y + 12);
  } else if(s.type === 'polygon'){
    if(s.points.length > 0){
      ctx.moveTo(s.points[0].x, s.points[0].y);
      for(let i=1; i<s.points.length; i++) ctx.lineTo(s.points[i].x, s.points[i].y);
      if(s.closed) ctx.closePath();
      ctx.fill(); ctx.stroke();
    }
  }

  if(highlight){
    ctx.globalCompositeOperation = 'xor'; // Glow effect
    ctx.stroke();
    ctx.globalCompositeOperation = 'source-over';
  }

  ctx.restore();
}

/* ... (keep the rest of the functions from previous version: shouldDrawLayer, pointInSheet, findShapeIndexAt, pointToSegmentDistance, isPointInPolygon, clampShapeToSheet, updateStats, polygonArea, buildExplorer (updated below), updateProp, updatePolygonPoint, deleteShape, copyShape, selectShape, optimizeLayout, estimateWasteAt, simulateTrajectory, download, exportDXF, exportGCode, exportPDF) ... */

/* Updated buildExplorer for accordion */
function buildExplorer(){
  const container = $id('properties');
  container.innerHTML = '';
  shapes.forEach((s,i)=>{
    if(!shouldDrawLayer(s.layer)) return;
    const details = document.createElement('details');
    details.className = 'property-panel tooltip';
    const summary = document.createElement('summary');
    summary.innerHTML = `<b>${i+1}. ${s.type.toUpperCase()} (${s.layer})</b> <small style="float:right;color:var(--text-secondary);">Clic pour éditer</small>`;
    const content = document.createElement('div');
    content.style.padding = '8px 0 0 0';
    let html = `<div class="row"><label>X (mm):</label><input type="number" value="${Math.round((s.x||s.points[0].x)/sheet.scale)}" onchange="updateProp(${i},'x',this.value)"></div>`;
    html += `<div class="row"><label>Y (mm):</label><input type="number" value="${Math.round((s.y||s.points[0].y)/sheet.scale)}" onchange="updateProp(${i},'y',this.value)"></div>`;
    if(s.type==='rect' || s.type==='triangle'){
      html += `<div class="row"><label>Largeur (mm):</label><input type="number" value="${Math.round(s.w/sheet.scale)}" onchange="updateProp(${i},'w',this.value)">`;
      html += `<label>Hauteur (mm):</label><input type="number" value="${Math.round(s.h/sheet.scale)}" onchange="updateProp(${i},'h',this.value)"></div>`;
      html += `<div class="row"><label>Rotation (°):</label><input type="number" value="${s.rotation||0}" onchange="updateProp(${i},'rotation',this.value)"></div>`;
    } else if(s.type==='circle'){
      html += `<div class="row"><label>Rayon (mm):</label><input type="number" value="${Math.round(s.r/sheet.scale)}" onchange="updateProp(${i},'r',this.value)"></div>`;
    } else if(s.type==='line'){
      html += `<div class="row"><label>X2 (mm):</label><input type="number" value="${Math.round(s.x2/sheet.scale)}" onchange="updateProp(${i},'x2',this.value)">`;
      html += `<label>Y2 (mm):</label><input type="number" value="${Math.round(s.y2/sheet.scale)}" onchange="updateProp(${i},'y2',this.value)"></div>`;
    } else if(s.type==='polygon'){
      html += `<div style="margin-top:8px;"><small>Points (éditez individuellement):</small></div>`;
      s.points.forEach((p, pi) => {
        html += `<div class="row"><label>Pt${pi} X:</label><input type="number" value="${Math.round(p.x/sheet.scale)}" onchange="updatePolygonPoint(${i},${pi},'x',this.value)">`;
        html += `<label>Y:</label><input type="number" value="${Math.round(p.y/sheet.scale)}" onchange="updatePolygonPoint(${i},${pi},'y',this.value)"></div>`;
      });
    }
    html += `<div class="btn-group" style="margin-top:8px;"><button class="small" onclick="deleteShape(${i})">Supprimer</button><button class="small" onclick="copyShape(${i})">Dupliquer</button></div>`;
    content.innerHTML = html;
    details.appendChild(summary);
    details.appendChild(content);
    if(pedagoMode.checked) details.title = `Éditez ${s.type} : drag sur canvas pour déplacer.`;
    details.addEventListener('toggle', () => { if(details.open) selectShape(i); });
    container.appendChild(details);
  });
}

/* Update updateProp for polygon x/y */
function updateProp(index, prop, value){
  const val = parseFloat(value) * sheet.scale;
  if(isNaN(val)) return;
  const s = shapes[index];
  if(prop === 'x' || prop === 'y'){
    const dx = val - (s.x || s.points[0].x);
    const dy = prop === 'x' ? 0 : val - (s.y || s.points[0].y);
    if(s.type === 'polygon'){
      s.points.forEach(p => { if(prop === 'x') p.x += dx; else p.y += dy; });
    } else {
      s[prop] = val;
      if(s.type === 'line' && prop === 'x') s.x2 += dx;
      if(s.type === 'line' && prop === 'y') s.y2 += dy;
    }
  } else {
    s[prop] = val;
  }
  clampShapeToSheet(s);
  redraw();
}

/* Keep other functions as is, but ensure normalizeShapeWH is called after w/h set in mousemove for rect/triangle */

/* Initial setup */
applySheetConfig();
redraw();

window.addEventListener('resize', () => {
  canvas.width = Math.max(800, window.innerWidth - (window.innerWidth > 1000 ? 600 : 0));
  canvas.height = Math.max(600, window.innerHeight - 60);
  applySheetConfig();
  redraw();
});
</script>
</body>
</html>
